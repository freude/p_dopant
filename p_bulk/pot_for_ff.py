"""
Module contains functions serving to generate the effective potential defined on a mesh
for the phosphorus donor in silicon. Th emesh should be previously generated
and stored in the file titled `mesh_sample.mesh`
"""
import os
import cPickle as pickle
import numpy as np
import logging as log
from scipy.interpolate import RegularGridInterpolator
from me2 import me2
import silicon_params as si


def read_txt_between_delimiters(file_name, del1, del2):
    """
    The function reads a block of text between lines marked by a specific text

    :param file_name:     path to the file
    :param del1:          a string denoting a line representing the first delimiter -
                          reading will start from the second line
    :type del1:           str
    :param del2:          a string denoting a line representing the second delimiter
                          reading will stop before this line
    :type del2:           str

    :return:              a block of text placed between two delimiters
    :rtype:               str
    """

    # initialize a block of text
    block = ""

    with open(file_name) as input_data:
        # Skips text before the beginning of the interesting block:
        for line in input_data:
            if line.strip() == del1:  # Or whatever test is needed
                break
        # Reads text until the end of the block:
        for line in input_data:  # This keeps reading the file
            if line.strip() == del2:
                break
            block+=line

    return block


def parse_mesh_file(path_to_mesh=None):
    """
    The function reads the mesh-file generated by the tool SaveMesh from FreeFem++

    :param path_to_mesh:  path to the file with extension .mesh

    :return:              2D array whith rows corresponding to mesh points and
                          columns representing their x, y and z coordinates
    :rtype:               numpy.array
    """

    if path_to_mesh is None:
        path_to_mesh = os.getcwd()
        path_to_mesh = os.path.join(path_to_mesh, 'p_dopant_data/mesh_sample.mesh')

    ind = read_txt_between_delimiters(path_to_mesh, 'Vertices', 'Tetrahedra')

    data_lines = ind.splitlines()
    data_lines = data_lines[1: -1]
    b = np.array([np.fromstring(j, dtype=float, sep=' ') for j in data_lines])

    return b[:, :3]


def pot_for_ff(k1, k2, file_ind):
    """
    The function generate an effective potential for an elastic electron
    scattering between valley with the wave vectors `k1` and `k2`.
    The effective potential will be stored in the file marked by
    the index file_ind with the file name pot[file_ind].txt

    :param k1:            first valley wave vector
    :param k2:            second valley wave vector
    :param file_ind:      file index for storage
    :return:
    """

    # -----------------------apply filter function - --------------------

    pwd = os.getcwd()
    log.info('Computing the smoothed potential on a regular grid...'),
    x, V1sm = me2(k1, k2, 'pot')
    log.info('Done!')

    # ----------------------------------------------------------------

    log.info('Read the mesh...'),
    b = parse_mesh_file()
    log.info('Done!')

    log.info('Build the interpolant for the potential...'),

    # prepare data

    if (k1 == k2).all():
        x = x[::2]
        V1sm = np.real(V1sm[::2, ::2, ::2])

    if not np.iscomplexobj(V1sm):
        if os.path.isfile(os.path.join(pwd, 'p_dopant_data/F' + str(file_ind) + '.pkl')):
            with open(os.path.join(pwd, 'p_dopant_data/F' + str(file_ind) + '.pkl'), 'rb') as input:
                F = pickle.load(input)
        else:
            V1sm = np.transpose(V1sm, (1, 0, 2))
            F = RegularGridInterpolator((x, x, x), V1sm, bounds_error=False)
            with open(os.path.join(pwd, 'p_dopant_data/F'+ str(file_ind) + '.pkl'), 'wb') as output:
                pickle.dump(F, output)

        log.info('Done!')

        log.info('Compute the potential on the mesh...'),
        pot = F(b)
        pot = np.nan_to_num(pot)
        log.info('Done!')

        log.info('Save the potential and the mesh...'),
        np.savetxt(os.path.join(pwd, 'p_dopant_data/pot' + str(file_ind) + '.txt'), pot)
        np.savetxt(os.path.join(pwd, 'p_dopant_data/mesh.dat'), b)
        log.info('Done!\n')

    else:

        if os.path.isfile(os.path.join(pwd, 'p_dopant_data/F'+ str(file_ind) + 'r.pkl')) and\
                os.path.isfile(os.path.join(pwd, 'p_dopant_data/F'+ str(file_ind) + 'i.pkl')):

            with open(os.path.join(pwd, 'p_dopant_data/F'+ str(file_ind) + 'r.pkl'), 'rb') as input:
                Fr = pickle.load(input)
            with open(os.path.join(pwd, 'p_dopant_data/F'+ str(file_ind) + 'i.pkl'), 'rb') as input:
                Fi = pickle.load(input)

        else:
            V1sm_r = np.transpose(np.real(V1sm), (1, 0, 2))
            V1sm_i = np.transpose(np.imag(V1sm), (1, 0, 2))
            Fr = RegularGridInterpolator((x, x, x), V1sm_r)
            Fi = RegularGridInterpolator((x, x, x), V1sm_i)

            with open(os.path.join(pwd, 'p_dopant_data/F'+ str(file_ind) + 'r.pkl'), 'wb') as output:
                pickle.dump(Fr, output)
            with open(os.path.join(pwd, 'p_dopant_data/F'+ str(file_ind) + 'i.pkl'), 'wb') as output:
                pickle.dump(Fi, output)

        log.info('Done!')

        log.info('Compute the potetnial on the mesh...')
        pot_r = Fr(b)
        pot_i = Fi(b)
        pot_r = np.nan_to_num(pot_r)
        pot_i = np.nan_to_num(pot_i)
        log.info('Done!')

        log.info('Save the potential and the mesh...'),
        np.savetxt(os.path.join(pwd, 'p_dopant_data/pot' + str(file_ind) + '.txt'), pot_r)
        np.savetxt(os.path.join(pwd, 'p_dopant_data/pot' + str(file_ind) + '.txt'), pot_i)
        np.savetxt(os.path.join(pwd, 'p_dopant_data/mesh.dat'), b)
        log.info('Done!')

def main():

    verbose = True

    if verbose:
        log.basicConfig(format="%(levelname)s: %(message)s", level=log.DEBUG)
        log.info("Verbose output.")
    else:
        log.basicConfig(format="%(levelname)s: %(message)s")


    k0 = si.k0 * si.ab

    kk = k0 * np.array([[1, 0, 0],
                        [-1, 0, 0],
                        [0, 1, 0],
                        [0, -1, 0],
                        [0, 0, 1],
                        [0, 0, -1]])

    pot_for_ff(kk[0, :], kk[0, :], '1')
    pot_for_ff(kk[1, :], kk[1, :], '2')
    pot_for_ff(kk[2, :], kk[2, :], '3')


if __name__  == '__main__':

    main()

